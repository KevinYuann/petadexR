#' Plot Multiple Plates in a Grid
#'
#' A thin wrapper around [plotPlate()].  When `shared_scale = TRUE` all plates
#' use a common min/max for the colour scale, ensuring a directly comparable
#' palette.  Plots are arranged with **gridExtra** in a near-square layout.
#'
#' @param plate_tbl  Tibble containing one or more plates (see [plotPlate()]).
#' @param fill_var   Column to map to colour.
#' @param circle_size Point size for each well.  Default 5.
#' @param log_transform Logical; if TRUE use log10 of `fill_var`.
#' @param viridis_palette Viridis option (`"viridis"`, `"magma"`, â€¦). Default `"viridis"`.
#' @param shared_scale Logical; if TRUE every plate shares a common colour range.
#' @param plate_ids Optional vector of plate IDs to plot (default = all).
#'
#' @return Invisibly returns the `gtable` generated by `gridExtra::grid.arrange()`.
#'
#' @export
plotPlates <- function(plate_tbl,
                       fill_var,
                       circle_size     = 5,
                       log_transform   = FALSE,
                       viridis_palette = "viridis",
                       shared_scale    = FALSE,
                       plate_ids       = NULL) {

  # ---- verify inputs ----------------------------------------------------- #
  if (!"plateID" %in% names(plate_tbl))
    usethis::ui_stop("`plate_tbl` must contain a `plateID` column.")
  if (!fill_var %in% names(plate_tbl))
    usethis::ui_stop("Variable '{fill_var}' not found in `plate_tbl`.")

  ids_all <- unique(plate_tbl$plateID)
  if (is.null(plate_ids)) {
    ids_sel <- ids_all
  } else {
    bad <- setdiff(plate_ids, ids_all)
    if (length(bad))
      warning("Requested plateID(s) not found: ",
              paste(bad, collapse = ", "), call. = FALSE)
    ids_sel <- intersect(plate_ids, ids_all)
    if (!length(ids_sel))
      usethis::ui_stop("None of the requested `plate_ids` were found.")
  }

  # ---- global colour limits --------------------------------------------- #
  limits <- NULL
  if (shared_scale) {
    rng <- plate_tbl |>
      dplyr::filter(.data$plateID %in% ids_sel) |>
      dplyr::mutate(v = .data[[fill_var]],
                    v = if (log_transform) log10(v) else v) |>
      dplyr::summarise(lo = min(v, na.rm = TRUE),
                       hi = max(v, na.rm = TRUE))
    limits <- c(rng$lo, rng$hi)
  }

  # ---- grid geometry ----------------------------------------------------- #
  n    <- length(ids_sel)
  ncol <- ceiling(sqrt(n))
  nrow <- ceiling(n / ncol)

  # ---- build one ggplot per plate --------------------------------------- #
  plots <- mapply(
    FUN = function(pid, i) {
      plotPlate(
        plate_tbl  = dplyr::filter(plate_tbl, .data$plateID == pid),
        fill_var   = fill_var,
        circle_size= circle_size,
        log_transform = log_transform,
        viridis_palette = viridis_palette,
        fill_limits = limits,
        show_legend = TRUE   # legend only on first plot
      )
    },
    pid = ids_sel,
    i   = seq_along(ids_sel),
    SIMPLIFY = FALSE
  )

  # ---- assemble grid ----------------------------------------------------- #
  grid_obj <- gridExtra::grid.arrange(grobs = plots, ncol = ncol, nrow = nrow)
  invisible(grid_obj)
}
